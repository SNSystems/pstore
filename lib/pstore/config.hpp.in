//===- pstore/config.hpp --------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
/// \file config.hpp
/// \brief Contains macros which determine the behavior of the PStore library.

#ifndef PSTORE_CONFIG_HPP
#define PSTORE_CONFIG_HPP (1)

#cmakedefine PSTORE_VENDOR_ID "@PSTORE_VENDOR_ID@"

#cmakedefine PSTORE_HAVE_STD_QUOTED 1

#cmakedefine PSTORE_HAVE_SYS_POSIX_SHM_H 1
#cmakedefine PSTORE_HAVE_LINUX_LIMITS_H 1

/// \brief Controls whether the library validates data header and footer structures
///        with a simple CRC value.
///
/// The data store file header and footer objects normally contain CRC values to ensure the
/// validity of the structures. However, fuzzing tools have more luck in finding exciting
/// bugs if these sanity checks are disabled; that's done by definining this macro as 0.
/// Naturally, the checks are enabled by default.
#cmakedefine PSTORE_CRC_CHECKS_ENABLED 1


/// \brief Controls the rate of data store file growth on POSIX systems.
///
/// Windows and Linux/Mac OS X handle memory-mapped files differently.
///
/// On Windows, if you start with an empty file and create a memory-mapped
/// view of 4Gb, then the operating system will forcibly increase the size of the file
/// to 4Gb. In essence there is a physical byte on the disk that corresponds to each
/// byte in a memory-mapped view.
///
/// By way of contrast, on our POSIX systems, it's possible to memory-mapp a region that's
/// much larger that the physical size of the file on disk. If we memory-map a view of
/// 4Gb on an empty file, then the file size is not automatically increased. If an attempt
/// is made to write to any of the mapped memory that lies beyond the end of the physical
/// file, then the process will crash. To avoid this, you must explicitly increase the size
/// of the underlying file; the advantage being that you can increase the file size on when
/// necessary for the data being stored.
///
/// The upshot of this is that our files grow in increments of the minimum allocation size
/// on Windows; a file containing 200 bytes of data will take up 4Mb. On POSIX, we have a choice:
/// follow the Windows behavior or increase the file size only as necessary. That's what this
/// this macro controls.
#cmakedefine PSTORE_POSIX_SMALL_FILES 1


/// \brief A debugging aid to make all data store requests "spanning".
///
/// The macro modifies the behaviour of the data store get() APIs such that an data request
/// is treated as a "spanning" request. A spanning request is one where the address data
/// record does not lie entirely within a single memory region.
///
/// This control is a debugging aid which flushes out inadvertant assumptions about the lifetime
/// of the pointers returned by database::get(). Enabling this behaviour results in every data
/// request returning a freshly allocated block of memory whose contents are copied from the
/// store. This contrasts with normal usage in which the majority of requests point directly
/// in persistent file-backed virtual memory.
#cmakedefine PSTORE_ALWAYS_SPANNING 1

#if defined(_WIN32) && PSTORE_POSIX_SMALL_FILES
// Sorry, but we can't do small files on Windows. They grow in increments of the
// minimum allocation size, like it or not.
#undef PSTORE_POSIX_SMALL_FILES
#endif

#endif // PSTORE_CONFIG_HPP
// eof:config.hpp
